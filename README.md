# FirstProjectSpringBoot<br>
This project is a Spring-based microservice that manages accounts. It has several components, including data transfer objects (DTOs), entities, enums, repositories, services, and web controllers.<br>
<br> 1) DTO: 
<br> a) VirementRequestDTO:<br>
The VirementRequestDTO class is a data transfer object (DTO) that is used to transfer information about a request to transfer funds between accounts. It has three fields: codeSource, codeDestination, and montant. These fields represent the source account, the destination account, and the amount to be transferred, respectively.<br> The @Data annotation from the Lombok library is used to generate getter and setter methods for these fields, as well as a toString() method, hashCode() and equals() methods, and a default constructor.<br>
In this case, the VirementRequestDTO class is used to transfer information about a request to transfer funds between accounts between the web controller and the CompteService service.
<br><br> 2) Entities:
<br> a) Compte.java :<br>
The Compte class is an entity that represents an account in the system. It has several fields that store information about the account, including its code, solde, dateCreation, and type.<br>
The @Entity annotation indicates that this class is an entity, which means that it can be stored in a database. The @Id and @GeneratedValue annotations are used to mark the code field as the primary key for the entity and to specify that the value for this field should be generated automatically by the database.<br>
The @Data annotation from the Lombok library is used to generate getter and setter methods for the fields, as well as a toString() method, hashCode() and equals() methods, and a default constructor. The @NoArgsConstructor and @AllArgsConstructor annotations are used to generate a no-argument constructor and an all-arguments constructor, respectively.<br>
The type field is annotated with the @Enumerated and @EnumType annotations. The @Enumerated annotation specifies that the type field is an enumerated type, and the @EnumType annotation specifies that the enumerated values should be stored as strings in the database. This is necessary because the TypeCompte enum is defined in a separate package and cannot be used directly in the Compte entity.
<br><br> b) CompteProj1.java :<br>
The CompteProj1 interface is a projection of the Compte entity. A projection is a way to define a custom view of an entity that includes only the fields that you want to include. This can be useful when you want to return a subset of the fields in an entity from a RESTful web service, for example.<br>
The @Projection annotation specifies that this interface is a projection and provides the name and the entity class to which it applies. The name attribute specifies the name of the projection, and the types attribute specifies the entity class. In this case, the projection is named p1 and applies to the Compte class.<br>
The CompteProj1 interface defines two methods, getCode() and getSolde(), which correspond to the code and solde fields of the Compte entity. These methods will be used to retrieve the values of these fields from the Compte entity when the projection is used.
<br><br> b) CompteProj2.java :<br>
the CompteProj2 interface is a projection of the Compte entity. It is used to define a custom view of the Compte entity that includes only the solde and type fields. The @Projection annotation specifies that this interface is a projection and provides the name and the entity class to which it applies. In this case, the projection is named p2 and applies to the Compte class.<br>
The CompteProj2 interface defines two methods, getSolde() and getType(), which correspond to the solde and type fields of the Compte entity. These methods will be used to retrieve the values of these fields from the Compte entity when the projection is used.<br>
The getType() method returns a TypeCompte enum, which represents the type of the account. This enum is defined in the tn.talan.compteservice.enums package and is used to represent the possible types of accounts, such as current or savings accounts.
<br><br>
The main difference between CompteProj1 and CompteProj2 is the fields that they include in their custom views of the Compte entity. The CompteProj1 interface includes only the code and solde fields, while the CompteProj2 interface includes only the solde and type fields. This means that if you use the CompteProj1 projection, you will only be able to retrieve the code and solde fields from the Compte entity, while if you use the CompteProj2 projection, you will only be able to retrieve the solde and type fields.<br>
<br><br> 3) Enums:
<br> a) TypeCompte.java :<br>
The TypeCompte enum defines the possible values for the type field of the Compte entity. It has two values, COURANT and EPARGNE, which likely represent the two types of accounts that are supported by the system: current accounts and savings accounts.<br>
Enums are useful for representing a fixed set of values that are known at compile time. In this case, the TypeCompte enum allows you to specify the type of an account in a type-safe way, without having to use a string or an integer value. This makes the code easier to read and maintain, and helps to prevent errors caused by using invalid values.
<br><br> 4) Repositories:
<br> a) CompteRepository.java :<br>
The CompteRepository interface is a repository that provides methods for storing and retrieving Compte entities from a database. It extends the JpaRepository interface from the Spring Data JPA library, which provides a set of common methods for working with data persistence, such as findAll(), save(), and delete().<br>
The @RepositoryRestResource annotation is used to specify that this interface should be exposed as a RESTful web service. This allows clients to access the methods in the repository over HTTP using the appropriate URL patterns.<br>
The CompteRepository interface defines a single method, findByType(), which is used to retrieve a list of Compte entities that have a specific type. The @RestResource annotation is used to specify the URL path that should be used to access this method. In this case, the URL path is /byType, which means that the method can be accessed at the /comptes/byType URL.<br>
The findByType() method takes a TypeCompte enum as an argument and returns a list of Compte entities that have the specified type. The @Param annotation is used to specify the name of the parameter that should be used in the URL query string when this method is called. In this case, the parameter is named type, so the method can be called with a URL like `/comptes/byType?type=COURANT
<br><br> 5) Services:
<br> a) CompteService.java<br>
The CompteService interface is a service that provides methods for managing accounts in the system. It defines a single method, virement(), which is used to transfer funds between two accounts.<br>
The virement() method takes three arguments: codeSource, codeDestination, and montant. These arguments likely represent the source account, the destination account, and the amount to be transferred, respectively.<br>
The CompteService interface is an example of the interface segregation principle, which states that a class should not be forced to implement methods that it does not use. In this case, the CompteService interface only defines the virement() method, which means that classes that implement this interface only need to provide an implementation for this method. This makes the CompteService interface easier to implement and maintain, and allows you to create more specialized service implementations that only need to provide specific functionality.
<br><br> b) CompteServiceImpl.java<br>
The CompteServiceImpl class is an implementation of the CompteService interface. It provides a concrete implementation of the virement() method, which is used to transfer funds between two accounts.<br>
The @Service annotation is used to specify that this class is a service component. This allows the class to be automatically detected by the Spring framework and registered as a bean in the application context.<br>
The @Transactional annotation is used to specify that this class uses transactional behavior. This means that any changes made to the data in the system will be automatically rolled back if an error occurs, which helps to ensure the consistency and integrity of the data.<br>
The CompteServiceImpl class has an @Autowired field named compteRepository, which is used to access the CompteRepository interface. This interface provides methods for storing and retrieving Compte entities from a database.<br>
The virement() method is the main implementation of the CompteService interface. It takes three arguments: codeSource, codeDestination, and montant. These arguments represent the source account, the destination account, and the amount to be transferred.<br>
<br><br> 6) Web:
<br> a) AccountRestController.java<br>
The AccountRestController class is a RESTful web service controller that provides endpoints for managing accounts in the system. It defines a single method, virement(), which is used to transfer funds between two accounts.<br>
The @RestController annotation is used to specify that this class is a web service controller. This allows the class to be automatically detected by the Spring framework and registered as a bean in the application context.<br>
The AccountRestController class has an @Autowired field named compteService, which is used to access the CompteService interface. This interface provides methods for managing accounts in the system, such as the virement() method.<br>
The virement() method is the main endpoint in the AccountRestController class. It is annotated with the @PutMapping annotation, which specifies that it should be accessed using the HTTP PUT method and the /comptes/virement URL pattern. The method takes a VirementRequestDTO object as an argument, which is annotated with the @RequestBody annotation. This means that the VirementRequestDTO object will be automatically mapped from the request body of the HTTP request.<br>
The virement() method calls the virement() method on the compteService object, passing the codeSource, codeDestination, and montant fields from the VirementRequestDTO object as arguments. This causes the funds to be transferred between the two accounts.
<br><br> b) CompteRestController.java<br>
The CompteRestController class is a RESTful web service controller that provides endpoints for managing Compte entities in the system. It defines methods for retrieving a list of accounts, retrieving a single account, creating a new account, updating an existing account, and deleting an account.<br>
The @RestController annotation is used to specify that this class is a web service controller. This allows the class to be automatically detected by the Spring framework and registered as a bean in the application context.<br>
The CompteRestController class has a constructor that takes a CompteRepository object as an argument. This object is used to access the CompteRepository interface, which provides methods for storing and retrieving Compte entities from a database.<br>
The listComptes() method is annotated with the @GetMapping annotation, which specifies that it should be accessed using the HTTP GET method and the /comptes URL pattern. This method retrieves all Compte entities from the database using the findAll() method of the compteRepository object, and returns them as a List of Compte objects.<br>
The getCompte() method is also annotated with the @GetMapping annotation, but it specifies the /comptes/{id} URL pattern. This means that the id parameter will be automatically extracted from the URL and passed as an argument to the getCompte() method. The method uses this id argument to call the findById() method on the compteRepository object and returns the resulting Compte entity.<br>
The save() method is annotated with the @PostMapping annotation, which specifies that it should be accessed using the HTTP POST method and the /comptes URL pattern. This method takes a Compte object as an argument, which is annotated with the @RequestBody annotation. This means that the Compte object will be automatically mapped from the request body of the HTTP request. The method then calls the save() method on the compteRepository object and returns the resulting Compte entity.<br>
The @PutMapping annotation maps the update method to the /comptes/{code} path and specifies that it expects a Compte object to be passed in the request body and a code value to be passed in the URL path. When this endpoint is called, the update method will use the provided code value to set the code property of the Compte object and then use the compteRepository to save the updated Compte object to the repository.<br>
The @DeleteMapping annotation maps the delete method to the /comptes/{code} path and specifies that it expects a Compte object to be passed in the request body and a code value to be passed in the URL path. When this endpoint is called, the delete method will use the provided code value to delete the Compte object with the matching code property from the repository.<br>
<br><br> 7) Main:
<br> a) CompteServiceApplication.java<br>
This code is the main class of a Java Spring Boot application that defines a set of REST API endpoints for a Compte resource. The main method is the entry point of the application, and it uses the SpringApplication.run method to start the application.<br>
The @SpringBootApplication annotation is a convenience annotation that combines several other annotations, including @Configuration, @EnableAutoConfiguration, and @ComponentScan. These annotations tell Spring to use the classpath to search for other components, configure Spring based on the dependencies that are on the classpath, and enable Spring Boot's autoconfiguration feature.<br>
The @Bean annotation on the start method tells Spring to create an instance of the CommandLineRunner interface and register it as a bean in the application context. This means that the run method of the CommandLineRunner will be executed when the application is started.<br>
In this case, the run method is using the provided compteRepository to save a few Compte objects to the repository and then print the type and solde properties of all the Compte objects in the repository to the console. The run method is also using the restConfiguration to expose the id property of the Compte class so that it can be used in the application's REST API.<br>
